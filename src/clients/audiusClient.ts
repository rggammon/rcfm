/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.9.4.0 (NJsonSchema v10.3.1.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

// NSwag Studio with:
// https://raw.githubusercontent.com/AudiusProject/api-docs/ff7c1513de0e2d0caf00e5a46dfdcb58fa5ac5b9/swagger/swagger.json

export interface IAudiusClient {
    /**
     * Search for a playlist
     * @param query Search Query
     * @param only_downloadable (optional) 
     */
    search_Playlists(query: string, only_downloadable: string | null | undefined): Promise<Playlist_search_result>;
    /**
     * Fetch a playlist
     * @param playlist_id A Playlist ID
     */
    get_Playlist(playlist_id: string): Promise<Playlist_response>;
    /**
     * Fetch tracks within a playlist
     * @param playlist_id A Playlist ID
     */
    get_Playlist_Tracks(playlist_id: string): Promise<Playlist_tracks_response>;
    /**
     * Resolves and redirects a provided Audius app URL to the API resource URL it represents
     * @param url URL to resolve. Either fully formed URL (https://audius.co) or just the absolute path
     */
    resolve(url: string): Promise<void>;
    /**
     * Search for a track
     * @param query Search Query
     * @param only_downloadable (optional) Return only downloadable tracks
     */
    search_Tracks(query: string, only_downloadable: string | null | undefined): Promise<Track_search>;
    /**
     * Gets the top 100 trending (most popular) tracks on Audius
     * @param genre (optional) Trending tracks for a specified genre
     * @param time (optional) Trending tracks over a specified time range (week, month, allTime)
     */
    trending_Tracks(genre: string | null | undefined, time: string | null | undefined): Promise<Tracks_response>;
    /**
     * Fetch a track
     * @param track_id A Track ID
     */
    get_Track(track_id: string): Promise<Track_response>;
    /**
     * Get the track's streamable mp3 file
     * @param track_id A Track ID
     * @return Success
     */
    stream_Track(track_id: string): Promise<void>;
    /**
     * Seach for a user
     * @param query Search query
     * @param only_downloadable (optional) 
     */
    search_Users(query: string, only_downloadable: string | null | undefined): Promise<User_search>;
    /**
     * Fetch a single user
     * @param user_id A User ID
     */
    get_User(user_id: string): Promise<User_response>;
    /**
     * Fetch favorited tracks for a user
     * @param user_id A User ID
     */
    get_User_Favorite_Tracks(user_id: string): Promise<Favorites_response>;
    /**
     * Fetch a list of tracks for a user
     * @param user_id A User ID
     */
    get_User_Tracks(user_id: string): Promise<Tracks_response>;
}

export class AudiusClient implements IAudiusClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/v1";
    }

    /**
     * Search for a playlist
     * @param query Search Query
     * @param only_downloadable (optional) 
     */
    search_Playlists(query: string, only_downloadable: string | null | undefined): Promise<Playlist_search_result> {
        let url_ = this.baseUrl + "/playlists/search?";
        if (query === undefined || query === null)
            throw new Error("The parameter 'query' must be defined and cannot be null.");
        else
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (only_downloadable !== undefined && only_downloadable !== null)
            url_ += "only_downloadable=" + encodeURIComponent("" + only_downloadable) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearch_Playlists(_response);
        });
    }

    protected processSearch_Playlists(response: Response): Promise<Playlist_search_result> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Playlist_search_result.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad request", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Playlist_search_result>(<any>null);
    }

    /**
     * Fetch a playlist
     * @param playlist_id A Playlist ID
     */
    get_Playlist(playlist_id: string): Promise<Playlist_response> {
        let url_ = this.baseUrl + "/playlists/{playlist_id}";
        if (playlist_id === undefined || playlist_id === null)
            throw new Error("The parameter 'playlist_id' must be defined.");
        url_ = url_.replace("{playlist_id}", encodeURIComponent("" + playlist_id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet_Playlist(_response);
        });
    }

    protected processGet_Playlist(response: Response): Promise<Playlist_response> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Playlist_response.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad request", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Playlist_response>(<any>null);
    }

    /**
     * Fetch tracks within a playlist
     * @param playlist_id A Playlist ID
     */
    get_Playlist_Tracks(playlist_id: string): Promise<Playlist_tracks_response> {
        let url_ = this.baseUrl + "/playlists/{playlist_id}/tracks";
        if (playlist_id === undefined || playlist_id === null)
            throw new Error("The parameter 'playlist_id' must be defined.");
        url_ = url_.replace("{playlist_id}", encodeURIComponent("" + playlist_id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet_Playlist_Tracks(_response);
        });
    }

    protected processGet_Playlist_Tracks(response: Response): Promise<Playlist_tracks_response> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Playlist_tracks_response.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad request", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Playlist_tracks_response>(<any>null);
    }

    /**
     * Resolves and redirects a provided Audius app URL to the API resource URL it represents
     * @param url URL to resolve. Either fully formed URL (https://audius.co) or just the absolute path
     */
    resolve(url: string): Promise<void> {
        let url_ = this.baseUrl + "/resolve?";
        if (url === undefined || url === null)
            throw new Error("The parameter 'url' must be defined and cannot be null.");
        else
            url_ += "url=" + encodeURIComponent("" + url) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResolve(_response);
        });
    }

    protected processResolve(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 302) {
            return response.text().then((_responseText) => {
            return throwException("Internal redirect", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Search for a track
     * @param query Search Query
     * @param only_downloadable (optional) Return only downloadable tracks
     */
    search_Tracks(query: string, only_downloadable: string | null | undefined): Promise<Track_search> {
        let url_ = this.baseUrl + "/tracks/search?";
        if (query === undefined || query === null)
            throw new Error("The parameter 'query' must be defined and cannot be null.");
        else
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (only_downloadable !== undefined && only_downloadable !== null)
            url_ += "only_downloadable=" + encodeURIComponent("" + only_downloadable) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearch_Tracks(_response);
        });
    }

    protected processSearch_Tracks(response: Response): Promise<Track_search> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Track_search.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad request", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Track_search>(<any>null);
    }

    /**
     * Gets the top 100 trending (most popular) tracks on Audius
     * @param genre (optional) Trending tracks for a specified genre
     * @param time (optional) Trending tracks over a specified time range (week, month, allTime)
     */
    trending_Tracks(genre: string | null | undefined, time: string | null | undefined): Promise<Tracks_response> {
        let url_ = this.baseUrl + "/tracks/trending?";
        if (genre !== undefined && genre !== null)
            url_ += "genre=" + encodeURIComponent("" + genre) + "&";
        if (time !== undefined && time !== null)
            url_ += "time=" + encodeURIComponent("" + time) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTrending_Tracks(_response);
        });
    }

    protected processTrending_Tracks(response: Response): Promise<Tracks_response> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Tracks_response.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad request", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Tracks_response>(<any>null);
    }

    /**
     * Fetch a track
     * @param track_id A Track ID
     */
    get_Track(track_id: string): Promise<Track_response> {
        let url_ = this.baseUrl + "/tracks/{track_id}";
        if (track_id === undefined || track_id === null)
            throw new Error("The parameter 'track_id' must be defined.");
        url_ = url_.replace("{track_id}", encodeURIComponent("" + track_id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet_Track(_response);
        });
    }

    protected processGet_Track(response: Response): Promise<Track_response> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Track_response.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad request", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Track_response>(<any>null);
    }

    /**
     * Get the track's streamable mp3 file
     * @param track_id A Track ID
     * @return Success
     */
    stream_Track(track_id: string): Promise<void> {
        let url_ = this.baseUrl + "/tracks/{track_id}/stream";
        if (track_id === undefined || track_id === null)
            throw new Error("The parameter 'track_id' must be defined.");
        url_ = url_.replace("{track_id}", encodeURIComponent("" + track_id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStream_Track(_response);
        });
    }

    protected processStream_Track(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 216) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad request", status, _responseText, _headers);
            });
        } else if (status === 416) {
            return response.text().then((_responseText) => {
            return throwException("Content range invalid", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Seach for a user
     * @param query Search query
     * @param only_downloadable (optional) 
     */
    search_Users(query: string, only_downloadable: string | null | undefined): Promise<User_search> {
        let url_ = this.baseUrl + "/users/search?";
        if (query === undefined || query === null)
            throw new Error("The parameter 'query' must be defined and cannot be null.");
        else
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (only_downloadable !== undefined && only_downloadable !== null)
            url_ += "only_downloadable=" + encodeURIComponent("" + only_downloadable) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearch_Users(_response);
        });
    }

    protected processSearch_Users(response: Response): Promise<User_search> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User_search.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad request", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User_search>(<any>null);
    }

    /**
     * Fetch a single user
     * @param user_id A User ID
     */
    get_User(user_id: string): Promise<User_response> {
        let url_ = this.baseUrl + "/users/{user_id}";
        if (user_id === undefined || user_id === null)
            throw new Error("The parameter 'user_id' must be defined.");
        url_ = url_.replace("{user_id}", encodeURIComponent("" + user_id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet_User(_response);
        });
    }

    protected processGet_User(response: Response): Promise<User_response> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User_response.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad request", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User_response>(<any>null);
    }

    /**
     * Fetch favorited tracks for a user
     * @param user_id A User ID
     */
    get_User_Favorite_Tracks(user_id: string): Promise<Favorites_response> {
        let url_ = this.baseUrl + "/users/{user_id}/favorites";
        if (user_id === undefined || user_id === null)
            throw new Error("The parameter 'user_id' must be defined.");
        url_ = url_.replace("{user_id}", encodeURIComponent("" + user_id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet_User_Favorite_Tracks(_response);
        });
    }

    protected processGet_User_Favorite_Tracks(response: Response): Promise<Favorites_response> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Favorites_response.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad request", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Favorites_response>(<any>null);
    }

    /**
     * Fetch a list of tracks for a user
     * @param user_id A User ID
     */
    get_User_Tracks(user_id: string): Promise<Tracks_response> {
        let url_ = this.baseUrl + "/users/{user_id}/tracks";
        if (user_id === undefined || user_id === null)
            throw new Error("The parameter 'user_id' must be defined.");
        url_ = url_.replace("{user_id}", encodeURIComponent("" + user_id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet_User_Tracks(_response);
        });
    }

    protected processGet_User_Tracks(response: Response): Promise<Tracks_response> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Tracks_response.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad request", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Tracks_response>(<any>null);
    }
}

export class User_response implements IUser_response {
    data?: User | undefined;

    constructor(data?: IUser_response) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? User.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): User_response {
        data = typeof data === 'object' ? data : {};
        let result = new User_response();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUser_response {
    data?: User | undefined;
}

export class User implements IUser {
    album_count!: number;
    bio?: string | undefined;
    cover_photo?: Cover_photo | undefined;
    followee_count!: number;
    follower_count!: number;
    handle!: string;
    id!: string;
    is_verified!: boolean;
    location?: string | undefined;
    name!: string;
    playlist_count!: number;
    profile_picture?: Profile_picture | undefined;
    repost_count!: number;
    track_count!: number;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.album_count = _data["album_count"];
            this.bio = _data["bio"];
            this.cover_photo = _data["cover_photo"] ? Cover_photo.fromJS(_data["cover_photo"]) : <any>undefined;
            this.followee_count = _data["followee_count"];
            this.follower_count = _data["follower_count"];
            this.handle = _data["handle"];
            this.id = _data["id"];
            this.is_verified = _data["is_verified"];
            this.location = _data["location"];
            this.name = _data["name"];
            this.playlist_count = _data["playlist_count"];
            this.profile_picture = _data["profile_picture"] ? Profile_picture.fromJS(_data["profile_picture"]) : <any>undefined;
            this.repost_count = _data["repost_count"];
            this.track_count = _data["track_count"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["album_count"] = this.album_count;
        data["bio"] = this.bio;
        data["cover_photo"] = this.cover_photo ? this.cover_photo.toJSON() : <any>undefined;
        data["followee_count"] = this.followee_count;
        data["follower_count"] = this.follower_count;
        data["handle"] = this.handle;
        data["id"] = this.id;
        data["is_verified"] = this.is_verified;
        data["location"] = this.location;
        data["name"] = this.name;
        data["playlist_count"] = this.playlist_count;
        data["profile_picture"] = this.profile_picture ? this.profile_picture.toJSON() : <any>undefined;
        data["repost_count"] = this.repost_count;
        data["track_count"] = this.track_count;
        return data; 
    }
}

export interface IUser {
    album_count: number;
    bio?: string | undefined;
    cover_photo?: Cover_photo | undefined;
    followee_count: number;
    follower_count: number;
    handle: string;
    id: string;
    is_verified: boolean;
    location?: string | undefined;
    name: string;
    playlist_count: number;
    profile_picture?: Profile_picture | undefined;
    repost_count: number;
    track_count: number;
}

export class Cover_photo implements ICover_photo {
    _640x?: string | undefined;
    _2000x?: string | undefined;

    constructor(data?: ICover_photo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this._640x = _data["640x"];
            this._2000x = _data["2000x"];
        }
    }

    static fromJS(data: any): Cover_photo {
        data = typeof data === 'object' ? data : {};
        let result = new Cover_photo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["640x"] = this._640x;
        data["2000x"] = this._2000x;
        return data; 
    }
}

export interface ICover_photo {
    _640x?: string | undefined;
    _2000x?: string | undefined;
}

export class Profile_picture implements IProfile_picture {
    _150x150?: string | undefined;
    _480x480?: string | undefined;
    _1000x1000?: string | undefined;

    constructor(data?: IProfile_picture) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this._150x150 = _data["150x150"];
            this._480x480 = _data["480x480"];
            this._1000x1000 = _data["1000x1000"];
        }
    }

    static fromJS(data: any): Profile_picture {
        data = typeof data === 'object' ? data : {};
        let result = new Profile_picture();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["150x150"] = this._150x150;
        data["480x480"] = this._480x480;
        data["1000x1000"] = this._1000x1000;
        return data; 
    }
}

export interface IProfile_picture {
    _150x150?: string | undefined;
    _480x480?: string | undefined;
    _1000x1000?: string | undefined;
}

export class Tracks_response implements ITracks_response {
    data?: Track[] | undefined;

    constructor(data?: ITracks_response) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Track.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Tracks_response {
        data = typeof data === 'object' ? data : {};
        let result = new Tracks_response();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITracks_response {
    data?: Track[] | undefined;
}

export class Track implements ITrack {
    artwork?: Track_artwork | undefined;
    description?: string | undefined;
    genre?: string | undefined;
    id!: string;
    mood?: string | undefined;
    release_date?: string | undefined;
    remix_of?: Remix_parent | undefined;
    repost_count!: number;
    favorite_count!: number;
    tags?: string | undefined;
    title!: string;
    user!: User;
    duration!: number;
    downloadable?: boolean | undefined;
    play_count!: number;

    constructor(data?: ITrack) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.artwork = _data["artwork"] ? Track_artwork.fromJS(_data["artwork"]) : <any>undefined;
            this.description = _data["description"];
            this.genre = _data["genre"];
            this.id = _data["id"];
            this.mood = _data["mood"];
            this.release_date = _data["release_date"];
            this.remix_of = _data["remix_of"] ? Remix_parent.fromJS(_data["remix_of"]) : <any>undefined;
            this.repost_count = _data["repost_count"];
            this.favorite_count = _data["favorite_count"];
            this.tags = _data["tags"];
            this.title = _data["title"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.duration = _data["duration"];
            this.downloadable = _data["downloadable"];
            this.play_count = _data["play_count"];
        }
    }

    static fromJS(data: any): Track {
        data = typeof data === 'object' ? data : {};
        let result = new Track();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["artwork"] = this.artwork ? this.artwork.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["genre"] = this.genre;
        data["id"] = this.id;
        data["mood"] = this.mood;
        data["release_date"] = this.release_date;
        data["remix_of"] = this.remix_of ? this.remix_of.toJSON() : <any>undefined;
        data["repost_count"] = this.repost_count;
        data["favorite_count"] = this.favorite_count;
        data["tags"] = this.tags;
        data["title"] = this.title;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["duration"] = this.duration;
        data["downloadable"] = this.downloadable;
        data["play_count"] = this.play_count;
        return data; 
    }
}

export interface ITrack {
    artwork?: Track_artwork | undefined;
    description?: string | undefined;
    genre?: string | undefined;
    id: string;
    mood?: string | undefined;
    release_date?: string | undefined;
    remix_of?: Remix_parent | undefined;
    repost_count: number;
    favorite_count: number;
    tags?: string | undefined;
    title: string;
    user: User;
    duration: number;
    downloadable?: boolean | undefined;
    play_count: number;
}

export class Track_artwork implements ITrack_artwork {
    _150x150?: string | undefined;
    _480x480?: string | undefined;
    _1000x1000?: string | undefined;

    constructor(data?: ITrack_artwork) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this._150x150 = _data["150x150"];
            this._480x480 = _data["480x480"];
            this._1000x1000 = _data["1000x1000"];
        }
    }

    static fromJS(data: any): Track_artwork {
        data = typeof data === 'object' ? data : {};
        let result = new Track_artwork();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["150x150"] = this._150x150;
        data["480x480"] = this._480x480;
        data["1000x1000"] = this._1000x1000;
        return data; 
    }
}

export interface ITrack_artwork {
    _150x150?: string | undefined;
    _480x480?: string | undefined;
    _1000x1000?: string | undefined;
}

export class Remix_parent implements IRemix_parent {
    tracks?: Track_element[] | undefined;

    constructor(data?: IRemix_parent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["tracks"])) {
                this.tracks = [] as any;
                for (let item of _data["tracks"])
                    this.tracks!.push(Track_element.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Remix_parent {
        data = typeof data === 'object' ? data : {};
        let result = new Remix_parent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.tracks)) {
            data["tracks"] = [];
            for (let item of this.tracks)
                data["tracks"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRemix_parent {
    tracks?: Track_element[] | undefined;
}

export class Track_element implements ITrack_element {
    parent_track_id!: string;

    constructor(data?: ITrack_element) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parent_track_id = _data["parent_track_id"];
        }
    }

    static fromJS(data: any): Track_element {
        data = typeof data === 'object' ? data : {};
        let result = new Track_element();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parent_track_id"] = this.parent_track_id;
        return data; 
    }
}

export interface ITrack_element {
    parent_track_id: string;
}

export class Favorites_response implements IFavorites_response {
    data?: Favorite[] | undefined;

    constructor(data?: IFavorites_response) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Favorite.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Favorites_response {
        data = typeof data === 'object' ? data : {};
        let result = new Favorites_response();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFavorites_response {
    data?: Favorite[] | undefined;
}

export class Favorite implements IFavorite {
    favorite_item_id!: string;
    favorite_type!: string;
    user_id!: string;

    constructor(data?: IFavorite) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.favorite_item_id = _data["favorite_item_id"];
            this.favorite_type = _data["favorite_type"];
            this.user_id = _data["user_id"];
        }
    }

    static fromJS(data: any): Favorite {
        data = typeof data === 'object' ? data : {};
        let result = new Favorite();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["favorite_item_id"] = this.favorite_item_id;
        data["favorite_type"] = this.favorite_type;
        data["user_id"] = this.user_id;
        return data; 
    }
}

export interface IFavorite {
    favorite_item_id: string;
    favorite_type: string;
    user_id: string;
}

export class User_search implements IUser_search {
    data?: User[] | undefined;

    constructor(data?: IUser_search) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(User.fromJS(item));
            }
        }
    }

    static fromJS(data: any): User_search {
        data = typeof data === 'object' ? data : {};
        let result = new User_search();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUser_search {
    data?: User[] | undefined;
}

export class Playlist_response implements IPlaylist_response {
    data?: Playlist[] | undefined;

    constructor(data?: IPlaylist_response) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Playlist.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Playlist_response {
        data = typeof data === 'object' ? data : {};
        let result = new Playlist_response();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPlaylist_response {
    data?: Playlist[] | undefined;
}

export class Playlist implements IPlaylist {
    artwork?: Playlist_artwork | undefined;
    description?: string | undefined;
    id!: string;
    is_album!: boolean;
    playlist_name!: string;
    repost_count!: number;
    favorite_count!: number;
    total_play_count!: number;
    user!: User;

    constructor(data?: IPlaylist) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.artwork = _data["artwork"] ? Playlist_artwork.fromJS(_data["artwork"]) : <any>undefined;
            this.description = _data["description"];
            this.id = _data["id"];
            this.is_album = _data["is_album"];
            this.playlist_name = _data["playlist_name"];
            this.repost_count = _data["repost_count"];
            this.favorite_count = _data["favorite_count"];
            this.total_play_count = _data["total_play_count"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
        }
    }

    static fromJS(data: any): Playlist {
        data = typeof data === 'object' ? data : {};
        let result = new Playlist();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["artwork"] = this.artwork ? this.artwork.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["id"] = this.id;
        data["is_album"] = this.is_album;
        data["playlist_name"] = this.playlist_name;
        data["repost_count"] = this.repost_count;
        data["favorite_count"] = this.favorite_count;
        data["total_play_count"] = this.total_play_count;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPlaylist {
    artwork?: Playlist_artwork | undefined;
    description?: string | undefined;
    id: string;
    is_album: boolean;
    playlist_name: string;
    repost_count: number;
    favorite_count: number;
    total_play_count: number;
    user: User;
}

export class Playlist_artwork implements IPlaylist_artwork {
    _150x150?: string | undefined;
    _480x480?: string | undefined;
    _1000x1000?: string | undefined;

    constructor(data?: IPlaylist_artwork) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this._150x150 = _data["150x150"];
            this._480x480 = _data["480x480"];
            this._1000x1000 = _data["1000x1000"];
        }
    }

    static fromJS(data: any): Playlist_artwork {
        data = typeof data === 'object' ? data : {};
        let result = new Playlist_artwork();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["150x150"] = this._150x150;
        data["480x480"] = this._480x480;
        data["1000x1000"] = this._1000x1000;
        return data; 
    }
}

export interface IPlaylist_artwork {
    _150x150?: string | undefined;
    _480x480?: string | undefined;
    _1000x1000?: string | undefined;
}

export class Playlist_tracks_response implements IPlaylist_tracks_response {
    data?: Track[] | undefined;

    constructor(data?: IPlaylist_tracks_response) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Track.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Playlist_tracks_response {
        data = typeof data === 'object' ? data : {};
        let result = new Playlist_tracks_response();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPlaylist_tracks_response {
    data?: Track[] | undefined;
}

export class Playlist_search_result implements IPlaylist_search_result {
    data?: Playlist[] | undefined;

    constructor(data?: IPlaylist_search_result) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Playlist.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Playlist_search_result {
        data = typeof data === 'object' ? data : {};
        let result = new Playlist_search_result();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPlaylist_search_result {
    data?: Playlist[] | undefined;
}

export class Track_response implements ITrack_response {
    data?: Track | undefined;

    constructor(data?: ITrack_response) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? Track.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Track_response {
        data = typeof data === 'object' ? data : {};
        let result = new Track_response();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITrack_response {
    data?: Track | undefined;
}

export class Track_search implements ITrack_search {
    data?: Track[] | undefined;

    constructor(data?: ITrack_search) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Track.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Track_search {
        data = typeof data === 'object' ? data : {};
        let result = new Track_search();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITrack_search {
    data?: Track[] | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}